TODO
- polyrhythms and visualization would be fun.
	- polyrhythm will just use standard metronome sound (for now)
	- 
- why slight delay on first start, after not starting for a while



Transport.PPQ
Transport.position
Transport.swing 
Transport.ticks 

Extra features
- isn't there some crackle in the audio when you start drone or adjust volume? 
- light/dark modes
- use localStorage to save last settings on device.
- custom sound sample upload?
- MUI bottom right + icon for my contact info, suggestions, etc.
- create click tracks
- create practice sessions (after 4 beats, increase tempo...)
- can you include a tuner on here as well?
- can you collect user data (like how long they used the metronome, what tempos, etc., it could be anonymous)
- subdivisions of more speciifc rhythms, like syncopated


- ESLint auto format - NEED TO RUN THIS ./node_modules/.bin/eslint --ini 
	- but use settings in here: https://www.aleksandrhovhannisyan.com/blog/format-code-on-save-vs-code-eslint/#1-installing-eslint-optional-prettier
	
	
- Testing libraries?



import { actions, useAppState } from '../context/AppStateContext';
const { state, dispatch } = useAppState();


States:
	Time signature with Asymmetrical meter support
	- Tempo (with text indicator)
	- Playing or stopped
	- Beat indicator
	?Subdivisions
	Tone type 
	tap for tempo5
	- drone tone (is actually nice feature)
	- voice control to stop, start 
	- ability to change color theme?
modal
- sound type (sawtooth etc.)
- color theme



// resume audio context to prevent lag
	// useEffect(() => {
	// 	// Fix for The AudioContext is "suspended". Invoke Tone.start() from a user action to start the audio.
	// 	// even if it says it's running, there is a delay
	// 	const resumeAudioContext = () => {
	// 		Tone.start();
	// 		// console.log(Tone.context);
	// 		// console.log(Tone.context.state);
	// 		if (Tone.context.state !== 'running') {
	// 			// console.log('resuming audio context');
	// 			Tone.context.resume();
	// 		}
	// 	};
	// 	resumeAudioContext();
	// 	const intervalId = setInterval(resumeAudioContext, 5000);
	// 	return () => clearInterval(intervalId);
	// });


	
	